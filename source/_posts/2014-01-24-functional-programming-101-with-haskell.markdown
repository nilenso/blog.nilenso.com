---
title: "Functional Programming 101 - With Haskell"
kind: article
created_at: 2014-01-24 03:30:00 UTC
author: Tejas Dinkar
post_url: "http://blog.gja.in/2014/01/functional-programming-101-with-haskell.html"
layout: post
---
<p>In this blog post, I&#39;ll attempt to explain some basic concepts of Functional Programming, using Haskell. This blog post isn&#39;t about Haskell per-se, but about one way of approaching this problem, which demonstrates the benefits of functional programming.</p> <p>You can run most of these examples in ghci, by saving the contents of the example into a .hs file, loading up ghci and running :load file.hs.</p> <p>Many thanks to <a href="http://www.iit.edu/csl/cs/faculty/beckman_mattox.shtml">Mattox Beckman</a> for coming up with the programming exercise, and Junjie Ying for coming finding a better data structure for this explanation than I came up with.</p><h2 id='the-problem'>The Problem</h2><p>You are Hercules, about to fight the dreaded Hydra. The Hydra has 9 heads. When a head is chopped off, it spawns 8 more heads. When one of these 8 heads is cut off, each one spawns out 7 more heads. Chopping one of these spawns 6 more heads, and so on until the weakest head of the hydra will not spawn out any more heads.</p> <p>Our job is to figure out how many chops Hercules needs to make in order to kill all heads of the Hydra. And no, it&#39;s not n!.</p><h2 id='prelude-simple-overview-of-haskell-syntax'>Prelude: Simple Overview Of Haskell Syntax</h2><p>Before we dive into code, i&#39;ll explain a few constructs which are unique to Haskell, so it&#39;s easy for non Haskellers.</p> <ul><li>List Creation: You can create a list / array using the : operator. This can even be done lazily to get an infinite list. <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=basics-1.hs"></script><noscript>  <pre>let firstArray = 0:1:[2, 3]<br />-- [0, 1, 2, 3]<br />let infiniteOnes = 1:infiniteOnes<br />-- [1, 1, 1, 1, 1, ........................]<br />-- never stops, hit ctrl-C to get your interpreter back</pre></noscript></li><li>Defining Function: Looks just like defining a variable, but it takes parameters. One way they are different from other languages is the ability to do pattern matching to simplify your code. Here, I define a method that sums all the elements of a list. <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=basics-2.hs"></script><noscript>  <pre>sumOfElements []     = 0<br />sumOfElements (x:xs) = x + sumOfElements xs</pre></noscript></li><li>More List Foo: Adding lists can be done with ++. Checking if a list is empty can be done with null. You can use replicate to create a list with the same elements over and over. <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=basics-3.hs"></script><noscript>  <pre>[1] ++ [3]     -- [1, 3]<br />null []        -- True<br />null [1]       -- False<br />replicate 2 3  -- [3, 3]</pre></noscript></li></ul><h2 id='choosing-a-data-structure'>Choosing a data structure</h2><p>Let&#39;s choose a simple data structure to represent the hydra. We&#39;ll pick an array to represent the heads of the Hydra, using the <code>level</code> of each head as the value. The initial state of the Hydra (with 9 <code>level 9</code> heads) can be represented as follows: <code>[9, 9, 9, 9, 9, 9, 9, 9, 9]</code>.</p><h2 id='chopping-off-a-head'>Chopping off a head</h2><p>The whole point of functional programming is to build small functions and compose them later. We&#39;ll build a few functions, specific to our domain, and a few more general ones to orchestrate.</p> <p>Let&#39;s first build a specific function to chop off the Hydra&#39;s head. We know that chopping off one <code>level 9</code> head should result in 8 <code>level 8</code> heads (and 8 of the original <code>level 9</code> heads). This is represented as <code>[8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9]</code></p> <p>Let&#39;s build the chop function. It takes a single argument, and the current levels of the all live heads. It will return the state of the heads after chopping the first one.</p> <p>The three lines of code below map to these rules:</p> <ul><li>If there are no heads left, just return <code>[]</code></li><li>If we find that there is a level 1 head at the start of our list, just chop it off and return the rest of the array</li><li>If we find that there is a higher level head at the start of our list, spawn n - 1 heads in it&#39;s place</li></ul> <p><script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=chop.hs"></script><noscript>  <pre>chop []       = []<br />chop (1:xs)   = xs<br />chop (n:xs)   = (replicate (n - 1) (n - 1)) ++ xs<br />----------------------------------------------------<br />chop [1]<br />-- []<br />chop [4]<br />-- [3, 3, 3]<br />chop [3, 3, 3]<br />-- [2, 2, 3, 3]<br />chop [9,9,9,9,9,9,9,9,9]<br />-- [8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9]</pre></noscript></p><h2 id='repeatedly-chopping-heads'>Repeatedly chopping heads</h2><p>Our function chop is a pure function as, given some input, it always returns the same output, without any sort of side effects. Side effects is a general term for modifying inputs / IO Operations / DB Calls, and so on.</p> <p>Since chop is pure function, we can safely call it over and over. Let&#39;s build a list where each element is the result of chopping the previous element. <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=repeatedly-chop1.hs"></script><noscript>  <pre>repeatedlyChop heads = heads:repeatedlyChop (chop heads)<br />----------------------------------------------------------<br />repeatedlyChop [3]<br />-- [[3],[2,2],[1,2],[2],[1], [], [], [] ...]<br />-- this is an infinite list</pre></noscript></p> <p>This paradigm is so common, that we have a functional construct that does this: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:iterate">iterate</a>. We can replace the above code with the following: <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=repeatedly-chop2.hs"></script><noscript>  <pre>repeatedlyChop heads = iterate chop heads</pre></noscript></p><h2 id='truncate-that-infinite-list'>Truncate that infinite list</h2><p>Great, we now have built a list of all the states the Hydra is in while Hercules is busy chopping away at it. However, this list goes on forever (we never put in a termination condition in the earlier code), so let&#39;s do that now.</p> <p>We can use a simple empty check (null) to test if the hydra is still alive. Let&#39;s keep items as long as the Hydra is alive <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=takewhilealive.hs"></script><noscript>  <pre>takeWhileAlive (x:xs) = if null x then [] else x:(takeWhileAlive xs)</pre></noscript></p> <p>Putting the two together <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=iteratethroughheads.hs"></script><noscript>  <pre>repeatedlyChopTillDead heads = takeWhileAlive (repeatedlyChopTillDead heads)<br />----------------------------------------------------------------------------<br />repeatedlyChopTillDead [4]<br />-- [[4],[3,3,3],[2,2,3,3],[1,2,3,3],[2,3,3],[1,3,3],[3,3],[2,2,3],[1,2,3],[2,3],[1,3],[3],[2,2],[1,2],[2],[1]]</pre></noscript></p> <p>Again, these patterns are so common, that we can replace the entire thing with a single line. <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:takeWhile">takeWhile</a> keeps things in the list until the first element that doesn&#39;t match. <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=repeatedly-simple.hs"></script><noscript>  <pre>repeatedlyChopTillDead heads = takeWhile (not.null) (iterate chop heads)</pre></noscript></p><h2 id='finishing-up'>Finishing up</h2><p>Now that we have the sequence of chops needed to kill that Hydra, figuring out the number of chops is just a matter of figuring out how long the sequence is. <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=count-chops.hs"></script><noscript>  <pre>countOfChops heads = length (repeatedlyChopTillDead heads)<br />--------------------------------------------------<br />countOfChops [1] -- 1<br />countOfChops [3] -- 5<br />countOfChops [9,9,9,9,9,9,9,9,9] -- 986409 (this takes a while)</pre></noscript></p><h2 id='extending'>Extending</h2><p>Now that we&#39;ve solved the problem, what next? How easy is it to extend this? Let&#39;s add a new requirement: Hercules, though a half god, can only fight at most n Hydra heads at a time. If the number of Hydra heads goes above n, then hercules dies. Let&#39;s make a function <code>willHerculesDie</code> which takes two parameters, n and the Hydra.</p> <p>Turns out, this is pretty simple. We just need to count all the heads that are alive. If the count is more than n at any point, then we return true, and Hercules dies. <script src="https://gist.github.com/24df70ad958b0ba87e37.js?file=herculeswilldie.hs"></script><noscript>  <pre>willHerculesDie n heads = any (> n) (map length (repeatedlyChopTillDead heads))<br />----------------------------------------------------------------------------<br />willHerculesDie 37 [9,9,9,9,9,9,9,9,9] -- False<br />willHerculesDie 36 [9,9,9,9,9,9,9,9,9] -- True</pre></noscript></p><h2 id='so-what-next'>So what next?</h2><p>We&#39;ve built a bunch of really composable functions, and we can look at each one independently to tune the system.</p> <p>You can get Haskell set up with the <a href="http://www.haskell.org/platform/">Haskell Platform</a> and play around with the code <a href="https://gist.github.com/gja/24df70ad958b0ba87e37/#file-hydra-hs">here</a>.</p> <p>Some great books you can check out:</p> <ul><li><a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">Structure and Interpretation of Computer Programs</a></li><li><a href="http://learnyouahaskell.com/">Learn you a Haskell for Great Good</a> - Greatest Haskell Tutorial out there</li><li><a href="https://leanpub.com/fp-oo">Functional Programming for the Object-Oriented Programmer</a></li></ul> <p><hr /><b>If you liked this post, you could:</b><br /> <h4 style="text-align: center;">  <a class="twitter-follow-button" data-show-count="false" href="https://twitter.com/tdinkar">Follow @tdinkar</a></h4> <div style="text-align: center;">  <b><a href="http://news.ycombinator.com/item?id=7113259">upvote it</a> on Hacker News</b></div> <div style="text-align: center;">  <b>or just <a href="http://www.blogger.com/comment.g?blogID=9188785269813520484&postID=5931143789690992852">leave a comment</a></b></div> <br/></p>
<div class="author">
  <img src="http://nilenso.com/images/alumni/gja.webp" style="width: 96px; height: 96;">
  <span style="position: absolute; padding: 32px 15px;">
    <i>Original post by <a href="http://twitter.com/tdinkar">Tejas Dinkar</a> - check out <a href="http://blog.gja.in/">Side Effect Free Rants</a></i>
  </span>
</div>
